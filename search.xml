<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[tomcat]]></title>
    <url>%2Fjava%2Ftomcat%2F</url>
    <content type="text"><![CDATA[tomcat安装下载地址将 tomcat 文件夹复制到 /Library 目录下,然后修改权限 1sudo chmod 755 /Library/tomcat 添加环境变量 1export PATH=$PATH:/Users/yourname/Library/tomcat/bin 验证tomcat是否安装成功执行 startup.sh 命令启动 tomcat 1startup.sh 打开 http://localhost:8080 验证tomcat是否安装成功 ##配置Tomcat启动脚本 Tomcat的目录层次结构使用文本编辑器添加以下代码： 12345678910111213141516171819#!/bin/bashcase $1 instart)sh /Users/yourname/Library/tomcat/bin/startup.sh;;stop)sh /Users/yourname/Library/tomcat/bin/shutdown.sh;;restart)sh /Users/yourname/Library/tomcat/bin/shutdown.shsh /Users/yourname/Library/tomcat/bin/startup.sh;;*)echo “Usage: start|stop|restart”;;esacexit 0 /Users/yourname/Library/tomcat/bin 要根据tomcat实际的安装路径来写 将文件保存为 tomcat 小写并不带后缀，存放到 /usr/local/bin 或 /usr/bin 。赋予文件执行权限： 1chmod 777 tomcat 之后便可以在终端中简单地输入 tomcat start 和 tomcat stop 启用和关闭tomcat了。快捷命令如下： 123tomcat start tomcat stoptomcat restart Tomcat 目录的结构bin: 存放启动和关闭tomcat的脚本文件 conf：存放tomcat服务器的各种配置文件 lib: 存放tomcat服务器支撑的jar包 logs: 存放tomcat的日志文件 temp: 存放tomcat运行时产生的临时文件 webapps: web应用虽在目录，即供外界访问的web资源的存放目录 work: tomcat的工作目录 主要文件介绍bin catalina.sh 用于启动和关闭tomcat服务器configtest.sh 用于检查配置文件startup.sh 启动tomcat脚本shutdown.sh 关闭tomcat脚本 conf server.xml tomcat 的全局配置文件web.xml 为不同的tomcat配置的web应用设置缺省值的文件tomcat-users.xml tomcat用户认证的配置文件logging.properties tomcat通过自己内部实现的JAVA日志记录器来记录操作相关的日志context.xml：所有host的默认配置信息 logs localhost_access_log.2017-06-28.txt 访问日志localhost.2017-06-28.log 错误和其它日志manager.2017-06-28.log 管理日志catalina.2017-06-28.log tomcat启动或关闭日志文件 部署静态部署1.直接将 web 项目文件件拷贝到 webapps 目录中将 war 包直接拷贝到 webapps 目录中，服务器会自动解开这个 war 包，并在这个目录下生成一个同名的文件夹webapps 这个默认的应用目录也是可以改变。打开 tomcat 的 conf 目录下的 server.xml 文件，找到下面内容： 1&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; 将 appBase 修改即可。 2.在 server.xml 中指定在 tomcat 的配置文件中，一个 Web 应用就是一个特定的 Context ，可以通过在 server.xml 中新建 Context 里部署一个 JSP 应用程序。打开 server.xml 文件，在 Host 标签内建一个 Context ，内容如下。 12&lt;Context path =&quot;/hello&quot; docBase =&quot;/Users/yourname/workspace/hello/WebRoot&quot; debug =&quot;0&quot; privileged =&quot;true&quot;&gt;&lt;/Context&gt; 参数说明： path： 是虚拟路径；docBase： 是应用程序的物理路径；workDir： 是这个应用的工作目录，存放运行时生成的与这个应用相关的文件；debug： 则是设定 debug level, 0 表示提供最少的信息， 9 表示提供最多的信息privileged： 设置为 true 的时候，才允许 Tomcat 的 Web 应用使用容器内的 Servletreloadable： 如果为 true ，则 tomcat 会自动检测应用程序的 /WEB-INF/lib 和 /WEB-INF/classes 目录的变化，自动装载新的应用程序，可以在不重起 tomcat 的情况下改变应用程序，实现热部署antiResourceLocking 和 antiJARLocking： 热部署是需要配置的参数，默认 false 避免 更新了某个 webapp ，有时候 Tomcat 并不能把旧的 webapp 完全删除，通常会留下 WEB-INF/lib 下的某个 jar 包，必须关闭 Tomcat 才能删除，这就导致自动部署失败。设置为 true ， Tomcat 在运行对应的 webapp 时，会把相应的源文件和 jar 文件复制到一个临时目录里。 3.创建一个Context 文件在 conf\Catalina\localhost 目录中，新建一个 xml 文件，名字不可以随意取，要和 path 后的那个名字一致，按照下边这个 path 的配置， xml 的名字应该就应该是 hello （ hello.xml ），该 xml 文件的内容为： 12&lt;Context path =&quot;/hello&quot; docBase =&quot;/Users/yourname/workspace/hello/WebRoot&quot; debug =&quot;0&quot; privileged =&quot;true&quot;&gt;&lt;/Context&gt; 注：删除一个 Web 应用同时也要删除 webapps 下相应的文件夹和 server.xml 中相应的 Context ，还要将 Tomcat 的 conf/catalina/localhost 目录下相应的 xml 文件删除，否则 Tomcat 仍会去配置并加载。 动态部署先了解 tomcat 图形管理接口 Server Status 主要用来查看服务器的状态Manager App 主要用来管理应用程序的部署及监控Host Manager 主要用来管理虚拟主机 Manager 的四个管理角色： manager-gui - allows access to the HTML GUI and the status pagesmanager-script - allows access to the text interface and the status pagesmanager-jmx - allows access to the JMX proxy and the status pagesmanager-status - allows access to the status pages only 在用户认证的配置文件 tomcat-users.xml 文件中添加用户名和密码: 1234&lt;role rolename=&quot;tomcat&quot;/&gt;&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;admin-gui&quot;/&gt;&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;tomcat,manager-gui,admin-gui&quot;/&gt; 登陆 tomcat 管理控制台： http://localhost:8080/manager/html ，输入上面配置的用户名和密码后便可管理应用并动态发布。在 Context Path(required) 中输入 /yourwebname ，这代表你的应用的访问地址。XML Configration file URL 中要指定一个 xml 文件，比如我们在 /user/yourname/work/ 下建立一个 hellow.xml 文件，内容如下： 1234567891011121314151617&lt;Context reloadable=&quot;false&quot; /&gt;``` 其中 `docBase` 不用写了，因为在下一个文本框中填入。或者更简单点，这个文本框什么都不填，在 WAR or Directory URL: 中键入 /user/yourname/work/hello.war 即可，然后点击 Deploy 按钮，上面就可以看到了 web 应用程序，名字就 `Context Path(required)` 中的名字。 或者直接使用下面的 `Select WAR file uploae` 点击浏览选择 `war` 文件，然后点击`Deploy` 即可。 ### 远程部署首先你要知道远程服务1：IP或域名，2:用户名，密码 3:远程服务器已经装有 `ssh`登录到远程服务器（一般服务机都会提供ssh协议）：`ssh username@servername`接下来会提示输入密码：`password`密码正确后会进入服务提供的根目录中，这时候可以进入到tomact目录中.关闭tomcat服务要先进入tomcat的bin目录然后输入：`./shutdown.sh`启动tomcat服务要在bin 目录中输入：`./startup.sh`如果要查看启动运行日志可以进入logs目录下，然后输入： tail -f catalina.out1234这样就可以查看动态日志, `ctrl＋c` 退出复制本地文件到服务器 scp /path/filename username@servername:/path1234567复制目录到服务器使用 `scp -r `复制本地文件到服务器并重新启动 `tomcat` 就完成了部署。还有一些其它操作：删除某个文件目录（如果把 `-r` 换成 `-rf` 就不会每次让你一个一个确认了） rm -r 目标文件12 删除某个文件直接（执行删除时会提示是否要删除，输入：y 表示确认） rm 目标文件12编辑文件： vim server.xml1234567891011121314151617181920212223## 其它### jdk版本切换JDK的安装目录(版本号根据情况略有不同)&gt; JDK 1.6：/Library/Java/JavaVirtualMachines/1.6.0.jdk&gt; JDK 1.7：/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk&gt; JDK 1.8：/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk打开 `~/.bash_profile` 文件（zsh 打开` ~/.zshrc` ），添加如下内容```shell# 设置 JDK 6export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6` # 设置 JDK 7 export JAVA_7_HOME=`/usr/libexec/java_home -v 1.7` # 设置 JDK 8 export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8` #默认JDK 7 export JAVA_HOME=$JAVA_7_HOME #alias命令动态切换JDK版本 alias jdk6=&quot;export JAVA_HOME=$JAVA_6_HOME” alias jdk7=&quot;export JAVA_HOME=$JAVA_7_HOME” alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot; tomcat报错解决启动失败，在 catalina.2017-06-28.log 报如下面的错误 1org.apache.catalina.core.StandardContext.startInternal Context [/hello] startup failed due to previous errors 这个时候此应用就启动失败了，访问会出现404错误。但是日志里面也没有写具体是什么问题导致启动失败，对调试带来了一些困难，下面是解决方法：在 tomcat 的 conf/loggings.properties 文件或者该应用的 WEB-INF/classes 目录中新建一个 loggings.properties 文件，再加上以下两句： 123org.apache.catalina.core.ContainerBase.[Catalina].level = INFOorg.apache.catalina.core.ContainerBase.[Catalina].handlers = java.util.logging.ConsoleHandler 之后重启 tomcat，这样应用再启动失败后就可以在 tomcat 的 logs/catalina.out 或者 logs/localhost_yyyy_mm_dd 日志文件中找到更加详细的错误信息。 ssh链接错误在链接ssh时报如下错误 1Permanently added (RSA) to the list of known hosts 解决给 known_hosts 添加权限 1sudo chmod 600 ~/.ssh/known_hosts 参考链接Tomcat部署Web应用方法总结Tomcat系列之服务器的安装与配置以及各组件详解]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号支付]]></title>
    <url>%2Fjava%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[微信公众号支付开发配置首先申请公众号的支付功能，在微信公众平台打开 微信支付 的开发配置，配置 支付授权目录 （即调用支付接口的地址，以”/“结尾）。注：公众平台微信支付公众号支付授权目录、扫码支付回调URL配置入口将在8月1日迁移至商户平台（pay.weixin.qq.com） js接口安全域名和网络授权域名，都要设置好。登陆商户平台 设置 API秘钥 ，一定要记下来，这个和 AppSecret 一样的不能查看。证书的话退款等操作才需要，现在不需要先不下载。 资料首先在微信公众平台技术文档看到微信JS-SDK说明文档中有微信支付接口。发起一个微信支付请求 12345678910wx.chooseWXPay(&#123; timestamp: 0, // 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符 nonceStr: '', // 支付签名随机串，不长于 32 位 package: '', // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=***） signType: '', // 签名方式，默认为'SHA1'，使用新版支付需传入'MD5' paySign: '', // 支付签名 success: function (res) &#123; // 支付成功后的回调函数 &#125;&#125;); 备注：prepay_id 通过微信支付统一下单接口拿到，paySign 采用统一的微信支付 Sign 签名生成方法，注意这里 appId 也要参与签名，appId 与 config 中传入的 appId 一致，即最后参与签名的参数有appId, timeStamp, nonceStr, package, signType。 同时还有微信支付开发文档：https://pay.weixin.qq.com/wiki/doc/api/index.html查看公众号支付可以看到 12345678910111213141516171819202122232425function onBridgeReady()&#123; WeixinJSBridge.invoke( 'getBrandWCPayRequest', &#123; "appId":"wx2421b1c4370ec43b", //公众号名称，由商户传入 "timeStamp":"1395712654", //时间戳，自1970年以来的秒数 "nonceStr":"e61463f8efa94090b1f366cccfbbb444", //随机串 "package":"prepay_id=u802345jgfjsdfgsdg888", "signType":"MD5", //微信签名方式： "paySign":"70EA570631E4BB79628FBCA90534C63FF7FADD89" //微信签名 &#125;, function(res)&#123; if(res.err_msg == "get_brand_wcpay_request:ok" ) &#123;&#125; // 使用以上方式判断前端返回,微信团队郑重提示：res.err_msg将在用户支付成功后返回 ok，但并不保证它绝对可靠。 &#125; ); &#125;if (typeof WeixinJSBridge == "undefined")&#123; if( document.addEventListener )&#123; document.addEventListener('WeixinJSBridgeReady', onBridgeReady, false); &#125;else if (document.attachEvent)&#123; document.attachEvent('WeixinJSBridgeReady', onBridgeReady); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady); &#125;&#125;else&#123; onBridgeReady();&#125; 这两个应该都可以用，我用的 js-sdk 的方法。 开发在微信支付开发文档下载SDK与DEMO，我是用的java开发，所以下载的java版，查看 readme 文件，可以看到SDK的使用方法：安装 使用maven配置类 Config 需要 appiId（公众号id） ， mchId（商户号） 和 apiKey（API秘钥） ，证书可以先注释掉。 根据readme中的统一下单来demo获取预支付交易会话标识 prepay_id需要的参数有 body 商品描述 参数规定 detail 商品详情 对于使用单品优惠的商户，改字段必须按照规范上传，单品优惠参数说明 total_fee 订单总金额 单位为分，详见支付金额 fee_type 标价币种 符合ISO 4217标准的三位字母代码，默认人民币：CNY 货币类型详细列表 out_tradeno 商户订单号 要求32个字符内，只能是数字、大小写字母-|*@ ，且在同一个商户号下唯一 device_info 设备号 非必输，公众号内支付可以传”WEB” spbill_create_ip 终端IP APP和网页支付提交用户端ip, request.getRemoteAddr() 获取 notify_url 通知地址 异步接收微信支付结果通知的回调地址，通知url必须为外网可访问的url，不能携带参数。 trade_type 交易类型 JSAPI(微信公众号) openid 用户标识 trade_type=JSAPI时（即公众号支付），此参数必传，此参数为微信用户在商户对应appid下的唯一标识 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** 支付* * @param request* @param response* @return* @throws Exception*/@RequestMapping(value = "/pay", method = RequestMethod.POST)@ResponseBodypublic String wechatPay(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; Map&lt;String, Object&gt; ret = new HashMap&lt;String, Object&gt;(); Gson gson = new Gson(); // 获取用户信息 Customer customer = getLoginUserInfo(request); WeChatPayConfig config = WeChatPayConfig.getInstance(); WXPay wxpay = new WXPay(config); HashMap&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); data.put("body", "测试-充值"); data.put("detail", ""); data.put("out_trade_no", getTradeNo(customer.getPhone())); data.put("device_info", ""); data.put("fee_type", "CNY"); data.put("total_fee", getFinalMoney(request.getParameter("money"))); data.put("spbill_create_ip", request.getRemoteAddr()); data.put("notify_url", getRequestPath(request) + "/wxPay/wechat_notify"); data.put("trade_type", "JSAPI"); data.put("openid", customer.getOpenid()); try &#123; Map&lt;String, String&gt; result = wxpay.unifiedOrder(data); String prepay_id = result.get("prepay_id"); Map&lt;String, String&gt; paySignMap = getPaySign(prepay_id, request); ret.put("items", paySignMap); ret.put("success", true); &#125; catch (Exception e) &#123; logger.error("wechat/pay Exception e:[" + e.getMessage().toString() + "]"); ret.put("success", false); ret.put("message", e.getMessage().toString()); &#125; return gson.toJson(ret);&#125; WeChatPayConfig 配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.io.ByteArrayInputStream;import java.io.InputStream;import com.github.wxpay.sdk.WXPayConfig;public class WeChatPayConfig implements WXPayConfig &#123; private byte[] certData; private static WeChatPayConfig PAYCONFIG; public WeChatPayConfig() throws Exception &#123; // String certPath = "/path/apiclient_cert.p12"; // File file = new File(certPath); // InputStream certStream = new FileInputStream(file); // this.certData = new byte[(int) file.length()]; // certStream.read(this.certData); // certStream.close(); &#125; public static WeChatPayConfig getInstance() throws Exception &#123; if (PAYCONFIG == null) &#123; synchronized (WeChatPayConfig.class) &#123; if (PAYCONFIG == null) &#123; PAYCONFIG = new WeChatPayConfig(); &#125; &#125; &#125; return PAYCONFIG; &#125; public String getAppID() &#123; return WeChatConstant.WECHAT_APP_ID; &#125; public String getMchID() &#123; return WeChatConstant.WECHAT_MCH_ID; &#125; public String getKey() &#123; return WeChatConstant.WECHAT_API_KEY; &#125; public InputStream getCertStream() &#123; ByteArrayInputStream certBis = new ByteArrayInputStream(this.certData); return certBis; &#125; public int getHttpConnectTimeoutMs() &#123; return 8000; &#125; public int getHttpReadTimeoutMs() &#123; return 10000; &#125;&#125; 其它 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*** 验证签名* * @param prepay_id* @param request* @return* @throws Exception*/public Map&lt;String, String&gt; getPaySign(String prepay_id, HttpServletRequest request) throws Exception &#123; Map&lt;String, String&gt; paySignaram = new HashMap&lt;String, String&gt;(); String timestamp = WeixinUtils.create_timestamp(); String nonce_str = WeixinUtils.create_nonce_str(); paySignaram.put("appId", WeChatConstant.WECHAT_APP_ID); paySignaram.put("timeStamp", timestamp); paySignaram.put("nonceStr", nonce_str); paySignaram.put("package", "prepay_id=" + prepay_id); paySignaram.put("signType", "MD5"); String sign = WXPayUtil.generateSignature(paySignaram, WeChatConstant.WECHAT_API_KEY); paySignaram.put("paySign", sign); return paySignaram;&#125;/*** 金额转化为分为单位* * @param money* @return*/private String getFinalMoney(String money) &#123; float sessionMoney = Float.parseFloat(money); String finalMoney = String.format("%.2f", sessionMoney); finalMoney = finalMoney.replace(".", ""); int intMoney = Integer.parseInt(finalMoney); return String.valueOf(intMoney);&#125;/*** 订单编号* * @param phone* @return*/private String getTradeNo(String phone) &#123; return "ceshi" + phone + System.currentTimeMillis();&#125;/*** 获取当前目录* @param request* @return*/private String getRequestPath(HttpServletRequest request) &#123; String realPath = request.getScheme() // 当前链接使用的协议 + "://" + request.getServerName()// 服务器地址 + request.getContextPath();// 项目文件名 return realPath;&#125; 刚开始以为 paySign（支付签名），是和 prepay_id 一同返回的，后来在仔细看，JS-SDK的文档，如下 备注：prepay_id 通过微信支付统一下单接口拿到，paySign 采用统一的微信支付 Sign 签名生成方法，注意这里 appId 也要参与签名，appId 与 config 中传入的 appId 一致，即最后参与签名的参数有appId, timeStamp, nonceStr, package, signType。 paySign 是appId, timeStamp, nonceStr, package, signType来进行签名的，具体算法可以查看验证签名算法我直接用 WXPayUtil 中的签名方法。 调用1234567891011121314151617181920212223242526272829303132333435ajax_action(&#123; url:"&lt;%=basePath%&gt;/wxPay/pay", params:&#123; "money": payment, "name": "$&#123;name&#125;", &#125;, callback:function(data)&#123; if(data.success)&#123; wxpay(data.items); &#125;else &#123; alert(data.message); &#125; &#125;&#125;); function wxpay(data) &#123; wx.chooseWXPay(&#123; appId: data.appId, timestamp: data.timeStamp, // 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符 nonceStr: data.nonceStr, // 支付签名随机串，不长于 32 位 package: data.package, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=***） signType: data.signType, // 签名方式，默认为'MD5' paySign: data.paySign, // 支付签名 success: function (res) &#123; if(res.errMsg == "chooseWXPay:ok" ) &#123; alert("支付成功"); &#125;else&#123; alert(res.errMsg); &#125; &#125;, cancel:function(res)&#123; alert("取消支付"); &#125; &#125;);&#125; 文档中没有 appId，但是验证签名时有用到 appId ，所以把它加上可，不知道不加能不能调通。 回调地址，查看文档支付结果通知 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*** 微信支付回调页面* * @Title: wechatPayNotify* @return void* @throws Exception*/@RequestMapping(value = "/wechat_notify")public void wechatPayNotify(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; InputStream inStream = request.getInputStream(); ByteArrayOutputStream outSteam = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = 0; while ((len = inStream.read(buffer)) != -1) &#123; outSteam.write(buffer, 0, len); &#125; outSteam.close(); inStream.close(); String result = new String(outSteam.toByteArray(), "utf-8"); WeChatPayConfig config = WeChatPayConfig.getInstance(); WXPay wxpay = new WXPay(config); Map&lt;String, String&gt; map = wxpay.processResponseXml(result); String return_code = map.get("return_code"); String result_code = map.get("result_code"); String returnXml = ""; if (return_code.equals("SUCCESS")) &#123; if (result_code.equals("SUCCESS")) &#123; String out_trade_no = map.get("out_trade_no"); // 此处就是你的逻辑代码 logger.info("~~~~~~~~~~~付款成功~~~~~~~~~"); logger.info("微信支付回调：订单=" + out_trade_no); returnXml = setXML("SUCCESS", "OK"); &#125; else &#123; logger.info("~~~~~~~~~~~支付失败~~~~~~~~~"); returnXml = setXML("FAIL", "业务失败"); &#125; &#125; else &#123; logger.info("~~~~~~~~~~~支付失败~~~~~~~~~"); returnXml = setXML("FAIL", map.get("return_msg")); &#125; response.getWriter().write(returnXml);&#125;/*** 生成返回xml* * @param return_code* @param return_msg* @return*/public static String setXML(String return_code, String return_msg) &#123; return "&lt;xml&gt;&lt;return_code&gt;&lt;![CDATA[" + return_code + "]]&gt;&lt;/return_code&gt;&lt;return_msg&gt;&lt;![CDATA[" + return_msg + "]]&gt;&lt;/return_msg&gt;&lt;/xml&gt;";&#125; 同样的通知可能会多次发送给商户系统。商户系统必须能够正确处理重复的通知。需要返回正确的参数（xml文件） 问题 支付结果返回：invalid total_fee 这是微信支付提交的金额是不能带小数点的。 签名失败，可能是签名的键值大小写错误，如 timeStamp 签名时S大小，wx.chooseWXPay 时为小写。 业务处理，js返回的支付结果并不可靠，所以我们需要在回调结果中处理，没找到demo，所以我直接在获取临时订单 prepay_id 时，把订单存入数据库，在回调函数中更改订单状态，并进行业务处理。 回调结果多次，返回的xml错误，刚开始是使用 BufferedOutputStream 返回的，一直有问题，如下，不知道为什么。 1234BufferedOutputStream out = new BufferedOutputStream(response.getOutputStream()); out.write(resXml.getBytes()); out.flush(); out.close();]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring+Mybatis 多个数据源]]></title>
    <url>%2Fjava%2FSpring%2BMybatis%20%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
    <content type="text"><![CDATA[Spring+Mybatis 多个数据源一般我们都会一个项目只用一个 DB，但是也有特殊情况，可能会使用到多个 DB。下面是 Spring MVC + Mybatis 下的多数据源配置。 配置继承AbstractRoutingDataSourceAbstractRoutingDataSource 是spring提供的一个多数据源抽象类。spring会在使用事务的地方来调用此类的 determineCurrentLookupKey() 方法来获取数据源的key值。我们继承此抽象类并实现此方法： 123456789101112131415import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;/*** 实现spring多路由配置*/public class MultipleDataSource extends AbstractRoutingDataSource &#123; @Override public Logger getParentLogger() &#123; return null; &#125; @Override protected Object determineCurrentLookupKey() &#123; return DataSourceContextHolder.getDataSource(); &#125;&#125; 创建数据库切换类MultipleDataSource 类中通过 DataSourceContextHolder.getDataSource() 获取数据源的key值。此方法应该和线程绑定。 123456789101112131415161718192021222324252627/** * 数据库切换工具类 */public class DataSourceContextHolder &#123; // 数据源名称线程池 private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;String&gt;(); /** * 设置数据源 * @param datasource 数据源名称 */ public static void setDataSource(String datasource) &#123; contextHolder.set(datasource); &#125; /** * 获取数据源 * @return 数据源名称 */ public static String getDataSource() &#123; return contextHolder.get(); &#125; /** * 清空数据源 */ public static void clearDataSource() &#123; contextHolder.remove(); &#125;&#125; 创建数据库常量类1234public class DataSourceType &#123; public static final String DB1 = "dataSource1"; //数据源1 public static final String DB2 = "dataSource2"; //数据源2&#125; 配置数据库属性文件 dbcp.properties123456789101112131415initialSize=20maxActive=200maxIdle=20minIdle=1maxWait=20000data1.driver=com.mysql.jdbc.Driverdata1.url=jdbc:mysql://localhsot:3306/testdata1.username=admindata1.password=123456data2.driver=com.mysql.jdbc.Driverdata2.url=jdbc:mysql://localhsot:3307/testdata2.username=admindata2.password=123456 Spring配置文件重点 multipleDataSource，事务采用拦截器方式，并支持 @Transcational 注解方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!-- 数据源1：dataSource1--&gt;&lt;bean id="dataSource1" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;data1.driver&#125;" /&gt; &lt;property name="url" value="$&#123;data1.url&#125;" /&gt; &lt;property name="username" value="$&#123;data1.username&#125;" /&gt; &lt;property name="password" value="$&#123;data1.password&#125;" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 数据源2：dataSource2--&gt;&lt;bean id="dataSource2" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;data2.driver&#125;" /&gt; &lt;property name="url" value="$&#123;data2.url&#125;" /&gt; &lt;property name="username" value="$&#123;data2.username&#125;" /&gt; &lt;property name="password" value="$&#123;data2.password&#125;" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 多数据源bean创建 --&gt;&lt;bean id="multipleDataSource" class="com.utils.MultipleDataSource"&gt; &lt;description&gt;多数据源路由&lt;/description&gt; &lt;property name="targetDataSources"&gt; &lt;map key-type="java.lang.String"&gt; &lt;!-- 指定lookupKey和与之对应的数据源 --&gt; &lt;entry key="dataSource1" value-ref="dataSource1"&gt;&lt;/entry&gt; &lt;entry key="dataSource2" value-ref="dataSource2"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 这里可以指定默认的数据源 --&gt; &lt;property name="defaultTargetDataSource" ref="dataSource1" /&gt;&lt;/bean&gt;&lt;!-- 自动扫描mapping.xml文件 --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="multipleDataSource" /&gt; &lt;property name="mapperLocations" value="classpath:com/mapper/*.xml"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!--basePackage指定要扫描的包，在此包之下的映射器都会被搜索到。 可指定多个包，包与包之间用逗号或分号分隔 --&gt; &lt;property name="basePackage" value="com.mapper" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务管理 --&gt;&lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="multipleDataSource" /&gt;&lt;/bean&gt;&lt;!--声明式事务配置--&gt;&lt;tx:annotation-driven transaction-manager="txManager" /&gt;&lt;!--需要扫描的包--&gt;&lt;context:component-scan base-package="com" /&gt; 调用示例1234567@AutowiredTestMapper testMapper;public List&lt;Test&gt; queryTest(String id) throws Exception &#123; DataSourceContextHolder.setDataSource(DataSourceType.DB1); //设置数据源 return testMapper.queryInvestorsById(id); DataSourceContextHolder.clearDataSource(); //查询完清除DB类型&#125; 自定义注解自定义数据源注解类12345678910111213import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 数据源注解类 */@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface DataSource &#123; String value();&#125; 定义一个数据源切面类指定注解以后，我们可以通过AOP拦截所有service方法，在方法执行之前获取方法上的注解：即数据源的key值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.lang.reflect.Method;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.stereotype.Component;@Aspect@Component@Order(1) //请注意：这里order一定要小于tx:annotation-driven的order，即先执行DataSourceAspect切面，再执行事务切面，才能获取到最终的数据源public class DataSourceAspect &#123; /** * 切入点 service包及子孙包下的所有类 */ @Pointcut("execution(* com.service.*.*(..))") public void aspect() &#123; &#125; @Before("aspect()") public void before(JoinPoint point) &#123; Class&lt;?&gt; target = point.getTarget().getClass(); MethodSignature signature = (MethodSignature) point.getSignature(); Method method = signature.getMethod() ; DataSource dataSource = null ; //从类初始化 dataSource = this.getDataSource(target, method) ; //从接口初始化 if(dataSource == null)&#123; for (Class&lt;?&gt; clazz : target.getInterfaces()) &#123; dataSource = getDataSource(clazz, method); if(dataSource != null)&#123; break ;//从某个接口中一旦发现注解，不再循环 &#125; &#125; &#125; if(dataSource != null &amp;&amp; !StringUtils.isEmpty(dataSource.value()) )&#123; DataSourceContextHolder.setDataSource(dataSource.value()); &#125; &#125; @After("aspect()") public void after(JoinPoint point) &#123; //使用完记得清空 DataSourceContextHolder.clearDataSource(); &#125; /** * 获取方法或类的注解对象DataSource * @param target 类class * @param method 方法 * @return DataSource */ public DataSource getDataSource(Class&lt;?&gt; target, Method method)&#123; try &#123; //优先方法注解 Class&lt;?&gt;[] types = method.getParameterTypes(); Method m = target.getMethod(method.getName(), types); if (m != null &amp;&amp; m.isAnnotationPresent(DataSource.class)) &#123; return m.getAnnotation(DataSource.class); &#125; //其次类注解 if (target.isAnnotationPresent(DataSource.class)) &#123; return target.getAnnotation(DataSource.class); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); logger.error(MessageFormat.format("通过注解切换数据源时发生异常[class=&#123;0&#125;,method=&#123;1&#125;]：" , target.getName(), method.getName()),e) ; &#125; return null ; &#125;&#125; AOP顺序由于我使用的注解式事务，和我们的AOP数据源切面有一个顺序的关系。数据源切换必须先执行，数据库事务才能获取到正确的数据源。所以要明确指定 注解式事务和 我们AOP数据源切面的先后顺序。 我们数据源切换的AOP是通过注解来实现的，只需要在AOP类上加上一个 order(1) 注解即可，其中1代表顺序号。 注解式事务的是通过xml配置启动 1&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; order=&quot;2&quot; /&gt; 示例Demo在每个service方法前使用 @DataSource(&quot;数据源key&quot;) 注解即可。 12345678@AutowiredTestMapper testMapper;@DataSource(DataSourceType.DB1)@Transactional(readOnly = true, propagation = Propagation.REQUIRED, rollbackFor = Exception.class)public List&lt;Test&gt; queryTest(String id) &#123; return testMapper.queryInvestorsById(id);&#125; 参考链接Spring MVC+Mybatis 多数据源配置Spring+Mybatis 多个数据源配置]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2Fother%2Fgit%2F</url>
    <content type="text"><![CDATA[Git安装在 Mac 上安装 Git 有多种方式。 最简单的方法是安装 Xcode Command Line Tools。 Mavericks （10.9） 或更高版本的系统中，在 Terminal 里尝试首次运行 git 命令即可。 如果没有安装过命令行开发者工具，将会提示你安装。 使用图形化的 Git 安装工具,下载地址 安装完成之后就是开始使用了，git 有两种使用方式 GUI 和 命令行。使用 GUI 可以去git提供的GUI中选择，下面主要介绍命令行的使用方法。 获取 Git 仓库有两种取得 Git 项目仓库的方法。 第一种是在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库。 在现有目录中初始化仓库在当前目录执行 git init该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。你可通过 git add 命令来实现对指定文件的跟踪，然后执行 git commit 提交： 123git initgit add -agit commit -m 'initial project version' 也可以新建一个目录，将其初始化为 Git 代码库 1git init [project-name] 克隆现有的仓库当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。克隆仓库的命令格式是 git clone [url] 。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令： 1git clone https://github.com/libgit2/libgit2 如果想自定义本地仓库的名字可使用： 1git clone https://github.com/libgit2/libgit2 mylibgit 文件的操作检查当前文件状态使用 git status 查看当前文件状态,使用 git status -s 命令或 git status --short 命令，你将得到一种更为紧凑的格式输出。 1234git statusOn branch masterInitial commitnothing to commit (create/copy files and use "git add" to track) 这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是 master,这是默认的分支名。 现在，让我们在项目下创建一个新的 README 文件。 如果之前并不存在这个文件，使用 git status 命令，你将看到一个新的未跟踪文件 README： 12345678echo "git" &gt; READMEgit statusOn branch masterInitial commitUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) READMEnothing added to commit but untracked files present (use "git add" to track) 它告诉我有一个还未追踪的文件，并提示我可以使用 git add &lt;file&gt;... 把它加进去。 查看已暂存和未暂存的修改如果 git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令,git diff 可以看文件做了哪些变化它默认跟最新的一个commit进行比较。红色（前面有减号-）表示删除，绿色（前面有加号+）表示添加。 git diff --cached 查看已暂存的将要添加到下次提交里的内容 假如现在想撤销这些更改 git checkout -- .git checkout -- file 可以丢弃工作区的修改这里有两种情况：一种是自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 跟踪新文件更新状态使用 git add -A 或 git add . （空格+ 点） 表示当前目录所有文件 再次使用 git status 1234567git add READMEgit statusOn branch masterInitial commitChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: README 状态变了 README 处于暂存状态,说明add成功了.Changes to be committed 说明现在可以执行 commit 了git rm --cached &lt;file&gt;... 将文件从 stage 里移出 12git rm --cached READMErm 'README' git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了git reset HEAD XXX/XXX/XXX.Java 就是对某个文件进行撤销了HEAD，表示最新的版本 提交更新git commit -m &quot;提交信息&quot;将文件提交到 repository 里 1234git commit -m "first commit"[master (root-commit) a74782d] first commit 1 file changed, 1 insertion(+) create mode 100644 README git commit 这种方式会启动文本编辑器以便输入本次提交的说明。 提交时记录的是放在暂存区域的快照。 任何还未暂存的仍然保持已修改状态。如果觉得这么做略显繁琐，可以直接跳过使用暂存区域。只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤。 修改 README 文件，直接提交： 123git commit -a -m "commit"[master 1a61fd5] commit 1 file changed, 1 insertion(+) 提交之前不再需要 git add README 文件了，但是如果是未跟踪过（新建）的文件是不能被提交的，所以不建议这样用。 git commit --amend 重新提交,这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。就是代替上次提交的结果。 移除文件要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。 12git rm READMErm 'README' 相当于 12rm READMEgit add README 下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。 另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 --cached 选项： 1git rm --cached README 恢复文件如果还未提交缓存区（没add）直接使用 1git checkout -- README 即可恢复如果已提交缓存区，需要回到最近一次 git commit 或 git add 时的状态，再恢复。 12git reset HEADgit checkout -- README 移动文件要在 Git 中对文件改名 git mv file_from file_to 1git mv README README.md 相当于运行了下面三条命令 123mv README README.mdgit rm READMEgit add README.md 查看提交历史git log 可以看到提交的记录，会按提交时间列出所有的更新，最近的更新排在最上面。常用的选项如：git log -1 最近一次的提交git log -p -2 显示最近两次提交的内容差异git log --stat --stat 选项在每次提交的下面列出额所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了git log --pretty=oneline 将每个提交放在一行显示，查看的提交数很大时非常有用git log --pretty=oneline --graph --graph 选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史。 12345git logcommit a74782dd6876921c0a1fb338c4637afe722623d8Author: yourname &lt;youremail@email.com&gt;Date: Tue Jul 4 16:29:43 2017 +0800 first commit q键可以退出 版本回退git log --pretty=oneline 获取版本号的commit_idgit reset --hard commit_id 取版本号前7位也可以 Git 必须知道当前版本是哪个版本，在 Git 中，用HEAD表示当前版本，也就是最新的提交的，上一个版本就是 HEAD^，上上一个版本就是 HEAD^^，当然往上100个版本不可能写100个^ ，应写成 HEAD~100。 如何回到最新版呢git reflog 记录你的每一次命令。 123git reflog2008cf5 HEAD@&#123;2&#125;: reset: moving to HEADa74782d HEAD@&#123;13&#125;: commit (initial): first commit 第一行表示当前 HEAD 所在的版本号是 2008cf5 ，而之所以在这个版本号，是由于我们执行了 reset 命令。再用一次 reset，将 HEAD 指向 a74782dgit reset --hard a74782d回到第一次reset前的状态了 分支管理创建与合并创建dev分支，然后切换到dev分支： 1git checkout -b dev git checkout 命令加上-b参数表示创建并切换，相当于以下两条命令： git branch devgit checkout dev git branch 查看当前分支git branch 命令会列出所有分支，当前分支前面会标一个 * 号。 修改内容后提交，切换回 master 分支： 1git checkout master 修改的内容不见了,因为那个提交是在 dev 分支上，而 master 分支此刻的提交点并没有变 把 dev 分支的工作成果合并到 master 分支上 1git merge dev git merge 命令用于合并指定分支到当前分支。合并后就可以看到，和dev分支的最新提交是完全一样的。 合并完成后，就可以放心地删除 dev 分支了(不能删除当前分支)git branch -d dev 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在 master 分支上工作效果是一样的，但过程更安全。 合并冲突当分支中更改的内容在 master 分支已经更改，合并时会发生冲突。 1234git merge devAuto-merging README.mdCONFLICT (content): Merge conflict in README.mdAutomatic merge failed; fix conflicts and then commit the result. git status 也可以告诉我们冲突的文件Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存在提交。 123git addgit commit -m #提交git branch -d #最后，删除分支。 git log --graph 命令可以看到分支合并图 合并分支时，如果可能，Git会用 Fast forward 模式，但这种模式下，删除分支后，会丢掉分支信息强制禁用 Fast forward 模式，Git就会在 merge 时生成一个新的 commit 1git merge --no-ff -m "merge with no-ff" dev --no-ff 表示禁用 Fast forward-m 把 commit 描述写进去 Bug分支开发中，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。当前正在分支上进行的工作还没有提交，需要先存起来。Git还提供了 stash 功能，可以把当前工作现场储藏起来，等以后恢复现场后继续工作。 1git stash 现在，用 git status 查看工作区，就是干净的。然后再到 master 分支上创建分支，修改后和并，删除分支。 回到之前的分支，查看 stash 列表 1git stash list 两种方法恢复,git stash pop 方法，自动删除 stash 1git stash pop 还有一种就是先用 git stash apply 恢复，再删除 stash 内容。 12git stash apply stash@&#123;0&#125;git stash drop 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令 git stash apply stash@{0} 删除分支 git branch -D &lt;name&gt; 强行删除 远程分支当你从远程仓库克隆时，实际上Git自动把本地的 master 分支和远程的 master 分支对应起来了，并且，远程仓库的默认名称是 origin 1234git remot #查看远程库的信息git remote -v #显示更详细的信息 origin https://github.com/AIxiuxiu/anna.git (fetch) #抓取地址origin https://github.com/AIxiuxiu/anna.git (push) #推送地址 推送分支master分支 1git push origin master 推送其他分支比如 dev 1git push origin dev 创建分支 git checkout -b newbranch将新的分支推送到 github git push origin newbranch 抓取分支 git checkout -b dev origin/dev失败则需要建立本地分支和远程分支的关联 12git branch --set-upstream-to=origin/newbranchgit pull 注：多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。 标签管理打标签 git tag &lt;name&gt; ，默认标签是打在当前分支上最新提交的commit上的历史标签，找到历史提交的 commit id 12git log --pretty=oneline --abbrev-commitgit tag &lt;name&gt; commit_id #提交打标签 查看标签 git tag查看标签信息 git show &lt;tagname&gt; 创建带有说明的标签，用-a指定标签名，-m指定说明文字 1git tag -a &lt;标签名&gt; -m "说明文字" commit_id 删除标签 git tag -d &lt;tagname&gt; 推送某个标签到远程 git push origin &lt;tagname&gt; 一次性推送全部尚未推送到远程的本地标签 git push origin --tags 如果标签已经推送到远程，要删除远程标签就麻烦一点， 12git tag -d &lt;tagname&gt; #先从本地删除git push origin :refs/tags/&lt;tagname&gt; #从远程删除 github创建 SSH 公钥使用命令创建 ssh-key 1ssh-keygen -t rsa -C "youremail@example.com" 然后在用户主目录里找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥。然后登陆 GitHub，打开 Account settings，SSH Keys 页面：在 Key 文本框里粘贴 id_rsa.pub 文件的内容. 可以使用 ssh -T git@github.com 测试是否连接成功 12ssh -T git@github.comHi yourName! You've successfully authenticated, but GitHub does not provide shell access. 添加远程库登陆 GitHub，然后，在右上角找到 Create a new repository 按钮填写 Repository name 创建 Create repository新建本地仓库并关联 123456echo "# github" &gt;&gt; README.mdgit initgit add README.mdgit commit -m "first commit"git remote add origin https://github.com/yourName/repositoryName.gitgit push -u origin master 把一个已有的本地仓库与之关联 12git remote add origin https://github.com/AIxiuxiu/anna.gitgit push -u origin master 由于远程库是空的，我们第一次推送 master 分支时，加上了 -u 参数 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master 或 git push 推送最新修改。 从远程库克隆假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆最好勾选 Initialize this repository with a README，GitHub 会自动为我们创建一个 README.md 文件， 之后用命令 git clone 克隆一个本地库 1git clone https://github.com/AIxiuxiu/anna.git GitHub 支持 HTTPS 和 SSH 协议(建议使用 SSH ，快一点) Fork 项目首先在你要 fork 的项目点击 fork ，项目就会在你的空间中创建一个完全属于你的项目副本，但在你自己的计算机上并没有这个仓库的文件。使用 clone 把项目拷贝到本地。 通过配置 Git 来同步你 fork 的原始项目，复制原始项目的仓库 URL，命令行到本地项目目录。输入 git remove -v，按下回车键，你将会看到你的 fork 当前配置的远程仓库： 123git remote -vorigin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) 输入 git remote add upstream &lt;URL&gt; URL 原项目地址。再次输入 git remote -v。你将会看到你 fork 的 URL 作为原始的地址，而原始的仓库的 URL 作为 upstream。 123456git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.gitgit remote -vorigin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch)upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push) 从上游仓库 fetch 分支和提交点，提交给本地 master，并会被存储在一个本地分支 upstream/master切换到本地主分支(如果不在) git checkout master把 upstream/master 分支合并到本地 master 上，这样就完成了同步，并且不会丢掉本地修改的内容。 123git fetch upstreamgit checkout mastergit merge upstream/master 接着就是熟悉的推送本地仓库到远程仓库 1git push origin master 其他github 上最新和最酷的东西 Explore GitHubgithub 教程 gotgithub 忽略特殊文件需要.gitignore文件所有配置文件可以直接在线浏览：https://github.com/github/gitignore 加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了,如忽略 class 文件。 1234git add App.classThe following paths are ignored by one of your .gitignore files:App.classUse -f if you really want to add them. 可以用-f强制添加到Git： 1git add -f App.class 可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查： 12git check-ignore -v App.class.gitignore:3:*.class App.class 配置别名只需要敲一行命令，告诉Git，以后 st 就表示 status，如： 1234git config --global alias.st statusgit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br branch 把暂存区的修改撤销掉（unstage） 1git config --global alias.unstage 'reset HEAD' 配置一个git last，让其显示最后一次提交信息： 1git config --global alias.last 'log -1' 配置lg 1git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit" 加上 --global 是针对当前用户起作用的,如果不加，那只针对当前的仓库起作用。 每个仓库的Git配置文件都放在 .git/config 12345678910111213141516cat .git/config[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[remote "origin"] url = git@github.com:michaelliao/learngit.git fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"] remote = origin merge = refs/heads/master[alias] last = log -1 别名就在 [alias] 后面，要删除别名，直接把对应的行删掉即可 而当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件 .gitconfig 中 参考链接廖雪峰Git教程Git]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改AppStore中的公司名称]]></title>
    <url>%2FiOS%2F%E4%BF%AE%E6%94%B9AppStore%E4%B8%AD%E7%9A%84%E5%85%AC%E5%8F%B8%E5%90%8D%E7%A7%B0%2F</url>
    <content type="text"><![CDATA[修改AppStore中的公司名称公司更改了名字，所以appstore里的开发商名称需要更改，现在改好了，把过程记录一下，并不一定是最正确的方法。 代理人(agent)苹果客服必须确认你是苹果开发者账号代理人，才会给你修改。如果你不知道这个代理人是谁，或者这个代理人已经离职，而你拥有这个开发者账号和密码，那么登陆 Developer 打开 Membership 就能看见代理人是谁。 如果已经离职，你可以修改代理人信息，但是还要和代理人认证，所以直接对苹果客服声称自己就是代理人就即可。也可以添加管理员然后更换代理人。 更改名称联系苹果客服拨打苹果开发者(中国)电话 400-670-1855 告诉客服你要更改公司名称，必须要说你是代理人。或者用代理人的邮箱直接写邮件：“我需要更改公司名称”发送到 chinadev@asia.apple.com。 然后客服会给你发一封邮件，邮件中包括需要你提供的信息和邓白氏的联系方式。 12345678910111213141516171819202122您好：感谢您对开发者计划的支持。我是XXX，很高兴为您服务。请回复此电子邮件并提供以下信息，以协助我们处理您的申请：1) 您原来组织的中英文名称是什么？2) 您原来的组织是否有应用在 App Store 上发布或处于审核状态？3) 您请求更新是否是因为您的应用或原来的组织已被收购？如果是，请回答以下问题： • 只有应用被收购？还是组织也被收购？ • 组织被全盘收购？还是其中的某些部门被收购？ • 原来的组织仍在运营？还是已经解散？4) 您的新组织的中英文名称是什么？5) 您的新组织的地址和电话号码是什么（如果原来的地址和电话号码已更改）？6) 您的组织是否具有新的法人实体类型（例如 LLC）？7) 您的组织是否有新的“税务登记号”？如果有，请提供该编号。如果我们需要其他文件来验证此变更，我们将通知您。如果贵组织有 D-U-N-S 编号，建议您发送电子邮件至 D&amp;B，以确认您的档案处于最新状态：Dun &amp; Bradstreet 全球支持部门appdeveloper@dnb.com 如果你需要更该英文名称，你需要联系邓白氏，因为一个公司只有一个邓白氏编码，为了保证，你现在的新名称公司将沿用之前的邓白氏码。 联系邓白氏发送邮件到 appdeveloper@dnb.com，邮件内容是你需要修改的信息，并且一定要备注下：“请下单到中国邓白氏”！ 1234公司名称需要做一下更改：1.XXXX技术有限公司改为“xxxx有限公司”2.xxxx Technology Co., Ltd.改为"xxxx Co., Ltd.”备注：“请下单到中国邓白氏” 然后会收到苹果邓白氏的回复，大概如下： 123456789Thank you for submitting your D-U-N-S Number request / update to D&amp;B. It should be completed by 07/05/2017, or sooner.Your request id is: 100000-100000. A D&amp;B representative may be contacting you directly. Your cooperation will help to expedite the resolution of this request.Please contact applecs@dnb.com if you have any questions. 然后差不多第二天华夏邓白氏会联系你进行公司的信息核实。 12345678910111213141516您好， 我们是上海华夏邓白氏，现收到您在苹果网站提交的申请，在给到编码之前我们需要核实信息，原订单有给到编码是属于XXXX技术有限公司，若您不是该公司请不要使用编码，我们核实好信息后，系统会发送正确的编码给到您，拨打座机02988993783，该订单是6/28 到期，请最晚于6/28 下午1点前回复邮件，若不能及时取得联系，该订单只能无法确认处理了，谢谢 以下是需要核实的内容 公司的注册名字 中英文公司若更过注册名字，请写出之前名字公司的实际办公地址及邮编（邮编请写详细的） 中英文公司电话（请与办公地址的城市保持一致）公司有无分公司或办事处公司有无英文缩写或简称，有请写出公司企业性质（营业执照上的公司类型）公司大致的员工人数公司主营业务(一个最主要的业务)贵公司苹果项目负责人的名字，职务，性别，联系电话 回复之后等待回复，下面是华夏邓白氏回复的信息 12345稍后办理好，24小时内系统会自动发编码到苹果注册邮箱内，最晚14个工作日编码才能使用。若着急使用，可以在一周后尝试，但请注意尝试次数不要超过3次，超过次数编码会被锁住，解锁及注册方面问题请找苹果客服，电话：4006701855注：包含邓白氏编码的邮件是由系统自动发送的，里面的信息是当时您自己在苹果网站上提交的原始信息，并不是核实好的内容。由于使用编码时需要再次填写公司信息，请和今天核实好的公司名字与地址保持一致。 最后收到苹果发来的邓白氏编码，就说明已将更新完成了。 12345678910111213Your D-U-N-S Number request/update submitted on 6/21/2017 with ID Number 1000000-100000 has been completed. You may start using your number in 14 days.D-U-N-S Number: 111111111Resolution Description: Match Found via host investigation, host database updatedThe following information was submitted as part of your request:Business Name: xxxx co., LTDCity: xxCountry: xxxxThank you for using D&amp;B's Mini Investigation Service. 邮件会附带你公司之前的信息，而且说明最晚14天之后才会更新到苹果的数据库。这我也不知道如何去查询是否已更新。我是等了一个星期，然后使用 D-U-N-S Number look up tool 工具来查询的。更新之后就可以给苹果客服回复了(也就是第一封邮件)，所以如果要更新邓白氏最好新联系邓白氏，然后再联系苹果客服。 之后苹果会让你将你公司的营业执照以及公司变更名称证明发送给他。 1234567891011121314151617181920212223242526272829您好：我们负责跟进您对于更新帐户中所示公司名称的请求。关于您的请求，我们需要更进一步的信息。我已经开通您的上传功能。请您尝试使用以下的链接上传贵公司的营业执照以及公司变更名称证明：https://developer.apple.com/contact/file-upload/我们建议您使用 Apple 的 Safari 浏览器。请注意档案大小不可超过 5MB。我们接受以下档案类型：JPG、PNG、TIFF、以及 PDF。上传后请您回复此邮件。请使用 Safari 浏览器来上载您的文件。若您只是需要更新您的英文公司名称，请直接联系 Dun &amp; Bradstreet (D&amp;B)，并请求更新您的 D&amp;B 档案：Dun &amp; Bradstreet 全球支持部门appdeveloper@dnb.com在他们确认已更新您的英文公司名称后，请回复此电子邮件。请注意，我们最长可能需要 14 个工作日才能从 D&amp;B 收到更新后的公司名称并在我们的系统中进行更新。如果您有任何问题或需要进一步的帮助，欢迎与我们联系。我们的办公时间是北京时间周一至周五，09:00 至 17:00，电话号码是 4006 701 855。当您来电时请告知我们案例编号: 10000000000 以便我们可以快速的找到您的申请。 上传证明之后一两天就会把公司名称改过来。 看到这好像更改英文名称只需要联系邓白氏，更改 appstore 里的中文名称才需要联系苹果开发者。 参考链接如何修改AppStore中的公司名称]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>AppStore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvm node版本管理]]></title>
    <url>%2FMac%2Fnvm%20node%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%20%2F</url>
    <content type="text"><![CDATA[nvm管理 node 版本，nvm 地址 ##安装使用 curl 方式 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash 或 Wget 1wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash 验证是否安装成功 1command -v nvm 成功返回 nvm 完成后 nvm 就被安装在了 ~/.nvm 下，接下来就需要配一下环境变量，使用的 zsh 的话，就需要在 ~/.zshrc 这个配置文件中配置，否则在 ~/.profile 或 ~/.bash_profile 中配置。在配置文件中添加 12export NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; . "$NVM_DIR/nvm.sh" # This loads nvm 但是 . &quot;$NVM_DIR/nvm.sh&quot; 会拖慢终端的启动。解决方案 issue#860 使用 --no-use 和 手动指定默认 node 路径来加快执行速度默认路径可以通过 nvm which default 获取 123export NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; . "$NVM_DIR/nvm.sh" --no-useexport PATH=$HOME/.nvm/versions/node/v8.0.0/bin/:$PATH 输入 nvm 可以看到如下信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Node Version ManagerNote: &lt;version&gt; refers to any version-like string nvm understands. This includes: - full or partial version numbers, starting with an optional "v" (0.10, v0.1.2, v1) - default (built-in) aliases: node, stable, unstable, iojs, system - custom aliases you define with `nvm alias foo` Any options that produce colorized output should respect the `--no-colors` option.Usage: nvm --help Show this message nvm --version Print out the latest released version of nvm nvm install [-s] &lt;version&gt; Download and install a &lt;version&gt;, [-s] from source. Uses .nvmrc if available --reinstall-packages-from=&lt;version&gt; When installing, reinstall packages installed in &lt;node|iojs|node version number&gt; --lts When installing, only select from LTS (long-term support) versions --lts=&lt;LTS name&gt; When installing, only select from versions for a specific LTS line nvm uninstall &lt;version&gt; Uninstall a version nvm uninstall --lts Uninstall using automatic LTS (long-term support) alias `lts/*`, if available. nvm uninstall --lts=&lt;LTS name&gt; Uninstall using automatic alias for provided LTS line, if available. nvm use [--silent] &lt;version&gt; Modify PATH to use &lt;version&gt;. Uses .nvmrc if available --lts Uses automatic LTS (long-term support) alias `lts/*`, if available. --lts=&lt;LTS name&gt; Uses automatic alias for provided LTS line, if available. nvm exec [--silent] &lt;version&gt; [&lt;command&gt;] Run &lt;command&gt; on &lt;version&gt;. Uses .nvmrc if available --lts Uses automatic LTS (long-term support) alias `lts/*`, if available. --lts=&lt;LTS name&gt; Uses automatic alias for provided LTS line, if available. nvm run [--silent] &lt;version&gt; [&lt;args&gt;] Run `node` on &lt;version&gt; with &lt;args&gt; as arguments. Uses .nvmrc if available --lts Uses automatic LTS (long-term support) alias `lts/*`, if available. --lts=&lt;LTS name&gt; Uses automatic alias for provided LTS line, if available. nvm current Display currently activated version nvm ls List installed versions nvm ls &lt;version&gt; List versions matching a given &lt;version&gt; nvm ls-remote List remote versions available for install --lts When listing, only show LTS (long-term support) versions nvm ls-remote &lt;version&gt; List remote versions available for install, matching a given &lt;version&gt; --lts When listing, only show LTS (long-term support) versions --lts=&lt;LTS name&gt; When listing, only show versions for a specific LTS line nvm version &lt;version&gt; Resolve the given description to a single local version nvm version-remote &lt;version&gt; Resolve the given description to a single remote version --lts When listing, only select from LTS (long-term support) versions --lts=&lt;LTS name&gt; When listing, only select from versions for a specific LTS line nvm deactivate Undo effects of `nvm` on current shell nvm alias [&lt;pattern&gt;] Show all aliases beginning with &lt;pattern&gt; nvm alias &lt;name&gt; &lt;version&gt; Set an alias named &lt;name&gt; pointing to &lt;version&gt; nvm unalias &lt;name&gt; Deletes the alias named &lt;name&gt; nvm reinstall-packages &lt;version&gt; Reinstall global `npm` packages contained in &lt;version&gt; to current version nvm unload Unload `nvm` from shell nvm which [&lt;version&gt;] Display path to installed node version. Uses .nvmrc if available nvm cache dir Display path to the cache directory for nvm nvm cache clear Empty cache directory for nvmExample: nvm install v0.10.32 Install a specific version number nvm use 0.10 Use the latest available 0.10.x release nvm run 0.10.32 app.js Run app.js using node v0.10.32 nvm exec 0.10.32 node app.js Run `node app.js` with the PATH pointing to node v0.10.32 nvm alias default 0.10.32 Set default node version on a shellNote: to remove, delete, or uninstall nvm - just remove the `$NVM_DIR` folder (usually `~/.nvm`) 可以看到 nvm 的全部命令各项命令的详细用法及含义可参考 nvm文档 使用查看可用的安装版本： 1nvm ls-remote 最好使用 LTS(Long Term Support) 版本 安装 node 12nvm install v6.11.0nvm install node #最新版本 如果您想查看已安装的版本： 1nvm ls 注：如果已经安装了 node，最好先删除已安装的 node 和全局 node 模块(node_modules)。node 命令在 /usr/local/bin/nodenpm 命令在 /usr/local/lib[lib64]/node_modules/npm npm ls -g --depth=0 // 查看已经安装在全局的模块，以便删除这些全局模块后再按照不同的 node 版本重新进行全局安装 1234npm ls -g --depth=0 // 查看已经安装在全局的模块，以便删除这些全局模块后再按照不同的 node 版本重新进行全局安装sudo rm -rf /usr/local/lib/node_modules // 删除全局 node_modules 目录sudo rm /usr/local/bin/node // 删除 nodecd /usr/local/bin &amp;&amp; ls -l | grep "../lib/node_modules/" | awk '&#123;print $9&#125;'| xargs rm #删除全局 node 模块注册的软链 安装完成，nvm 会将各个版本的node安装在 ~/.nvm/versions/node 目录下 看看目录下有些什么，安装的版本文件 12ls -a ~/.nvm/versions/node. .. v6.11.0 nvm 会在 $PATH 前面安插指定版本的目录，可以确认实际的 $PATH 看看： 1echo $PATH 接下来我们可以使用 nvm use &lt;version&gt; 切换版本： 1nvm use v6.11.0 指定一个默认的 node 版本 12nvm alias default v6.11.0nvm current #查看当前版本 设置别名 nvm alias my_alias &lt;name&gt;，方便选择版本 1nvm alias 6 v6.11.0 nvm install 命令经常执行失败，这时你需要到 nodejs 官网下载你想安装的版本，解压缩，然后复制到 ~/.nvm/versions/node/ 文件夹中，同样可以使用 nvm 切换。 使用 .nvmrc 文件配置项目所使用的 node 版本 如果你的默认 node 版本（通过 nvm alias 命令设置的）与项目所需的版本不同，则可在项目根目录或其任意父级目录中创建 .nvmrc 文件，在文件中指定使用的 node 版本号 1234cd &lt;项目根目录&gt; #进入项目根目录echo "v6.11.0" &gt; .nvmrc #添加 .nvmrc 文件并指定版本nvm use #无需指定版本号，会自动使用 .nvmrc 文件中配置的版本node -v #查看 node 是否切换为对应版本 nvm 切换镜像源根据 nvm 官方提供的帮助文档，我们可以通过以下命令进行切换 1export NVM_NODEJS_ORG_MIRROR="http://npm.taobao.org/mirrors/node" http://npm.taobao.org/mirrors/node 是 淘宝NPM镜像 提供的国内 Node.js 的安装镜像源。 但是种方式，在每次重启终端都会失效。如果并不想每次打开终端，都需要重新设置 NVM_NODEJS_ORG_MIRROR 环境变量。需要在终端配置文件中添加： 12export NVM_NODEJS_ORG_MIRROR="http://npm.taobao.org/mirrors/node"source ~/.nvm/nvm.sh Windows 系统我们可以找到 nvm-windows 软件的安装目录中的 settings.txt 文件，增加以下内容: 1node_mirror=http://npm.taobao.org/mirrors/node/ npm 镜像npm 默认从国外的源 https://registry.npmjs.org/ 获取和下载包信息，国内访问速度很不理想。 国内 npm 镜像源 cnpmjs 镜像：搜索地址：https://cnpmjs.org/registry: https://r.cnpmjs.org/ 淘宝 npm 镜像：搜索地址：https://npm.taobao.org/registry: https://registry.npm.taobao.org/ 使用方法1.临时使用(不建议) 1npm install express --registry https://r.cnpmjs.org/ 2.持久使用 命令行修改 npm 配置 12npm config set registry https://r.cnpmjs.org/ #配置 registrynpm config get registry #验证配置是否修改成功 或添加 npm 配置文件 .npmrc 编辑 ~/.npmrc 加入下面内容 1registry = https://r.cnpmjs.org 参考链接node版本管理工具nvm-Mac下安装及使用使用nvm安装管理多个版本的node.js(适用于Mac和Windows系统)国内优秀npm镜像推荐及使用]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>nvm</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmder]]></title>
    <url>%2Fwin%2Fcmder%2F</url>
    <content type="text"><![CDATA[cmder简介Cmder是一款Windows环境下非常简洁美观易用的 cmd 替代者,因为它是即压即用的存在，所以点击根目录下的 Cmder.exe 即可运行。下载的时候，有两个版本，分别是 mini 与 full 版；唯一的差别在于有没有内建 msysgit 工具，这是 Git for Windows 的标准配备；全安装版 Cmder自带了 msysgit,除了 git 本身这个命令之外, 里面可以使用大量的 linux 命令；比如 grep, curl, tar, unzip, ssh, bash, perl 等。 配置 Cmder启动 Cmder1.把 Cmder 加到环境变量，把 Cmder.exe 存放的目录添加到系统环境变量 Path；加完之后, Win+r 一下输入 cmder,即可使用。2.添加 Cmder 到右键菜单，以管理员权限打开cmder终端输入以下语句回车即可: Cmder.exe /REGISTER ALL。3.使用AutoHotKey热键，在ahk文件中添加如下代码，则使用 Alt+c 来打开 cmder ,但有些新增命令无法使用，如 node npm 等。 12!c:: run, D:\**\cmder_mini\Cmder.exereturn 修改命令提示符号Cmder 预设的命列列提示符号是 λ;如果用着不习惯，可以将这个字元改成 Mac/Linux 环境下常见的 $ 符号，具体操作如下：打开 cmder 安装目录下的 \vendor\clink.lua 文件，将里面的 λ 替换为 $。但在使用 powerShell 时需要另行设置，将 \vendor\profile.ps1 文件中的 λ 替换为 $ 。 中文乱码在设置中添加语言环境，win+alt+p 打开设置面板，找到 Startup -&gt; Envrioment 选项在下面的文本框里添加一行 set LANG=zh_CN.UTF-8，然后重启。 样式背景的透明度,找到 Features -&gt; Transparency 选项就可调节透明度。Features -&gt; Colors 可以调节颜色，schemes 可以选择主题。 别名自定义 aliases 打开Cmder目录下的 config 文件夹，里面的 user-aliases 文件就是我们可以配置的别名文件。像下面几个。 123..=cd .. //输入..返回上一级文件夹gc=git commit -m $1 //git提交sbl="D:\Program Files\Sublime Text 3\sublime_text.exe" $1 -new_console:s50H //在窗口右边50%横向打开sublime 但 user-aliase 中的别名只能在 cmd 下使用，在使用 powershell 时需要编辑 \vendor\profile.ps1 文件,如 1234Set-Alias sbl "C:\Program Files\Sublime Text 3\sublime_text.exe"function Git-Status &#123; git status &#125;Set-Alias gs Git-Status 快捷键 打开设置面板 =&gt; Win+Alt+P 打开新的页签 =&gt; Ctrl+T 关闭页签 =&gt; Ctrl+W 切换页签 =&gt; Ctrl+Tab 关闭所有页签 =&gt; Alt+F4 快速打开一个 CMD =&gt; Shift+Alt+1 快速打开一个 PowerShell =&gt; Shift+Alt+2 快速打开一个 PowerShell(系统管理员权限) =&gt; Shift+Alt+2 快速切换到第 1 个页签 =&gt; Ctrl+1 快速切换到第 n 个页签(n值无上限) =&gt; Ctrl+n 历史命令搜索 =&gt; Ctr+r 全屏 =&gt; Alt+Enter Chocolatey 软件包管理Chocolatey 是用命令行来安装应用程序的个包管理工具。 安装 chocolatey使用cmd，运行如下命令即可 1@"%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe" -NoProfile -ExecutionPolicy Bypass -Command "iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))" &amp;&amp; SET "PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin" choco 安装软件安装软件命令 choco install softwareName, 短写是 cinst softwareName可安装的应用程序，默认安装在 C:\Program Files\，可以参见其 Package 列表 以下是 window 下开发常用的开发环境应用: 123456789101112choco install autohotkey.portable #安装 AutoHotkey (Portable)choco install nodejs.install #安装 nodechoco install git.install #安装 gitchoco install ruby #安装 rubychoco install python #安装 pythonchoco install jdk8 #安装 JDK8choco install googlechrome #安装 Chromechoco install google-chrome-x64 #Google Chrome (64-bit only)choco install firefox #安装 firefoxchoco install notepadplusplus.install #安装 notepad++choco install Atom #安装 Atomchoco install SublimeText3 #安装 SublimeText3 参考链接cmder 一个比cmd强n倍的神器在 windows 下安装 Cmderchocolateycmder]]></content>
      <categories>
        <category>win</category>
      </categories>
      <tags>
        <tag>cmder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oh-my-zsh 插件]]></title>
    <url>%2FMac%2Foh-my-zsh%20%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[oh-my-zsh 插件oh-my-zsh 自带很多插件，有兴趣可以看wiki的插件介绍 zsh-syntax-highlighting高亮 zsh 的关键字。 安装1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 在 ~/.zshrc 中的 plugins=() 处添加 zsh-syntax-highlighting autojump目录快速跳转，它会根据你 cd 的历史纪录智能判断你想去到哪个目录。也可以用 oh-my-zsh 自带的插件 z。 安装1brew install autojump 或 1234git clone git://github.com/joelthelion/autojump.gitcd autojump #解压缩后进入目录./install.py 根据提示在~/.zshrc 或 ~/.bash_profile 中添加 1[ -f /usr/local/etc/profile.d/autojump.sh ] &amp;&amp; . /usr/local/etc/profile.d/autojump.sh 在 ~/.zshrc 中的 plugins=() 处添加 autojump 使用cd 目录 之后，使用 j 文件名 就可以到文件目录 j -h 查看helpjc 打开子目录jo 打开目录的文件管理器jco 打开子目录的文件管理器 j --stat 各个目录的权重 j -i [权重] // 增加j -d [权重] // 减少 gitoh-my-zsh 默认开启的插件，提供了大量 git 的 alias。 提供git的 aliase 常用有： Alias Command gaa git add -all gst git status glola git log –graph –pretty = format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit –all gd git diff gcmsg git commit -m gpoat git push origin —all &amp;&amp; git push origin —tags gl git pull zsh-autosuggestions这是模仿 fish shell 的一个插件，作用基本上就是根据历史记录即时提示。 安装1git clone git：//github.com/zsh-users/zsh-autosuggestions $ ZSH_CUSTOM / plugins / zsh-autosuggestions 添加插件 plugins=(zsh-autosuggestions) 使用使用 →按键 、 End 或 ctrl+E 来完成。 更改颜色：将 配置文件 放到 $ZSH_CUSTOM （/Users/user/.oh-my-zsh/custom） 文件下更改 ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&#39;fg=8&#39; 颜色为iTerm的偏好设置（写颜色或数字0-15）。或者直接更改 Black Bright 的颜色。 icdiff安装1brew install icdiff 使用比较两个文件的差异 1icdiff &lt;file_1&gt; &lt;file_2&gt; git 用法 1git difftool --extcmd icdiff 精简用法 1git icdiff 如果你想直接git diff的时候直接用icdiff取代 在 /usr/local/bin/ 创建脚本 ext-diff 添加内容： 12#!/bin/shicdiff $2 $5 给脚本权限 1chmod +x ext-diff 在git配置文件 ~/.gitconfig 中添加 12[diff] external = /usr/local/bin/ext-diff 更新 source ~/.gitconfig 这样就替换git默认的diff，但不建议这样使用。 错误1UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position 32: ordinal not in range(128) 根据 issues36 可知，需要使用Python3，更改 /usr/local/Cellar/icdiff/1.9.0/bin/icdiff 文件的 #!/usr/bin/env python 为 #!/usr/bin/env python3。（已经安装python3）。 extract功能强大的解压插件，所有类型的文件解压一个命令x全搞定，再也不需要去记tar后面到底是哪几个参数了。 直接添加插件 plugins=(extract) sublime该插件可以使用命令行打开sublime。常用命令如下： 1234st # 直接打开sublimest file_a # 用sublime打开文件 filest dir_a # 用sublime打开目录 dirstt # 在sublime打开当前目录，相当于 st . 直接添加插件 plugins=(sublime) sudo它的作用就是连按两下 Esc 键在命令的开头加上或去掉 sudo 关键字。 直接添加插件 plugins=(sudo) 参考链接一些命令行效率工具我常用的 oh-my-zsh 插件issues14issues36]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>zsh</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm2 + oh my zsh]]></title>
    <url>%2FMac%2FiTerm2%20zsh%2F</url>
    <content type="text"><![CDATA[iTerm2 + oh my zshiTerm2iTerm2 下载地址 http://www.iterm2.com 偏好设置 打开热键 Preferences - Keys，勾选 Hotkey 中的 Show/hide iTerm2 with a system-wide hotkey，然后设定一个热键。如 Command + .，然后按 Command + . 就可以随时调出或者隐藏 iTerm2 了。 颜色主题 Preferences - Profiles - Colors 右下角 Color Presets 选择主题。或从 iTerm Themes 网站中下载第三方主题包，选择主题下的 import 操作，把下载的主题导入。 终端灰蒙蒙 Preferences - Profiles - Text - Text Rendering，将 Draw bold text in bright colors 前面的勾去掉。 复用上个会话的目录 Preferences - Profiles - Working Directory 勾选 Reuse previous session’s directory。 Solarized主题更改配色方案为 Solarized直接去主页下载或者使用 Git 1git clone git://github.com/altercation/solarized.git 然后双击 solarized/iterm2-colors-solarized/ 双击里面的文件，或 import 导入，然后再偏好设置中选择相应的主题。也有terminal的配色 solarized/osx-terminal.app-colors-solarized 双击，然后再偏好设置中更改默认主题。 Vim主题配置将 solarized/vim-colors-solarized/colors 中的 solarized.vim 文件复制到 ~/.vim/colors 目录下。定修改 .vimrc 文件。命令如下： 12345678$ cd solarized/vim-colors-solarized/colors$ mkdir -p ~/.vim/colors$ cp solarized.vim ~/.vim/colors/$ vi ~/.vimrcsyntax enableset background=darkcolorscheme solarized item2启动慢插件oh-my-zsh加载的插件太多 12vi ~/.zshrcplugins=(git autojump zsh-syntax-highlighting) 缓存清理系统日志 1sudo rm /private/var/log/asl/*.asl 打开 item2 时使用 /usr/bin/login 命令使用户登录 login 命令需要读取 asl 文件，当 asl 文件很大时就会拖慢启动速度。所以也可以不让 login 命令显示上次登录时间：打开 iTerm2 的偏好设置里，在 Profiles - General - Command 里选择为 Command，然后里边写入 /usr/bin/login -pfq xxx 其中 xxx 是你的用户名。 nvm. &quot;$NVM_DIR/nvm.sh&quot; 会拖慢了终端的启动。解决方案 issue#860 使用 --no-use 和 手动指定默认 node 路径来加快执行速度默认路径可以通过 nvm which default 获取 123export NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; . "$NVM_DIR/nvm.sh" --no-useexport PATH=$HOME/.nvm/versions/node/v8.0.0/bin/:$PATH iTerm2快捷键标签 新建标签：command + t 关闭标签：command + w 切换标签：command + 数字 / command + 左右方向键 分屏 垂直分屏：command + d 水平分屏：command + shift + d 屏幕 切换全屏：command + enter 清屏1：command + r 清屏2：ctrl + l 查找：command + f 查看历史命令：command + ; 查看剪贴板历史：command + shift + h 搜索命令历史：ctrl + r 文本编辑 交换光标处文本：ctrl + t 前进后退：ctrl + f/b (相当于左右方向键) 到行首：ctrl + a 到行尾：ctrl + e 删除当前光标的字符：ctrl + d 删除光标之前的字符：ctrl + h 删除到文本末尾：ctrl + k（光标后） 删除到文本开始：ctrl + u（光标前） 删除光标之前的单词：ctrl + w zshMac系统自带了 zsh,但不是最新版本的 zsh，使用 zsh --version 查看版本号，需要使用 5.x 版本，如果不是可以用 brew install 安装最新的 5.x。 1234brew install zshsudo rm /bin/zsh # 替换系统自带 zshsudo ln -s `brew --prefix zsh`/bin/zsh /bin/zshchsh -s /bin/zsh # 切换系统当前用户的默认 shell 为 zsh 安装完毕，Command + W 关闭 iTerm2 当前窗口，然后按 Command + . 重新打开，此时 shell 已经换成 zsh 了。切换到 bash 系统 1chsh -s /bin/bash oh-my-zshoh-my-zsh 是一套十分强大的 zsh 配置方案。具有自动补全参数和自定义配置功能。 安装curl 方式 1sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" wget 方式 1sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" 配置 zshrc修改 .zshrc(~/.zshrc) 文件 123ZSH_THEME="agnoster" # 使用 agnoster 主题，颜值高DEFAULT_USER="你的用户名" # 增加这一项，可以隐藏掉路径前面那串用户名plugins=(git autojump zsh-autosuggestions) # 自己按需把要用的 plugin 写上 .oh-my-zsh/themes 文件中是所有的主题文件，可任意挑选，Oh My Zsh提供的所有主题在线预览。 修改完后，刷新配置文件，然后重新启动 iTerm 主题就有了。 1source ~/.zshrc 会有乱码问题，这时还需要安装一个Mac的字体库 Powerline-patched font 12345678# clonegit clone https://github.com/powerline/fonts.git# installcd fonts./install.sh# clean-up a bitcd ..rm -rf fonts 安装完成之后，在偏好设置中把 Anti-aliased Font 和 Non-ASCII Font 都改为 powerline 的字体。 或者直接安装 Menlo 字体补丁下载并安装 1git clone https://github.com/abertsch/Menlo-for-Powerline.git Profiles / Text，把 Anti-aliased Font 和 Non-ASCII Font 都换成 Menlo。 如果使用 MacVim 选择相应的字体添加配置到 .vimrc: 1set guifont=Menlo\ for\ Powerline 命令别名如更新 cocoapods 时 输入 pod update --verbose --no-repo-update可使用命令别名来简化命令行的输入： 1alias pod_update=&apos;pod update --verbose --no-repo-update&apos; 可以使用alias命令来显示所有命令别名永久添加，添加到.zshrc中 1234alias zshconfig=&quot;vim ~/.zshrc&quot;alias tree=&quot;find . -print | sed -e &apos;s;[^/]*/;|____;g;s;____|; |;g’&quot;alias pod_update=&apos;pod update --verbose --no-repo-update&apos;alias pod_install=&apos;pod install --verbose --no-repo-update&apos; 其它补全zsh 的命令补全功能非常强大，可以补齐路径，补齐命令，补齐参数等。按下 tab 键显示出所有待选项后，再按一次 tab 键即进入选择模式，进入选择模式后，按 tab 切向下一个选项，按 shift+tab 键切向上一个选项，ctrl+f/b/n/p 可以向前后左右切换，或使用 上下左右 来切换。 跳转zsh 的目录跳转更为智能，你无需输入 cd，直接输入路径即可。.. 表示后退一级目录，../../ 表示后退两级，依次类推。（ ... 的作用和 ../../ 相同）。输入d，将列出当前 session 访问过的所有目录，再按提示的数字即可进入相应目录。 历史记录历史记录支持受限查找。比如，输入 git，再按向上箭头，会搜索用过的所有 git 命令。 通配符ls *.png 查找当前目录下所有 png 文件，ls **/*.png 递归查找。 Command 键按住 Command 键: 可以拖拽选中的字符串； 点击 url：调用默认浏览器访问该网址； 点击文件夹：在 finder 中打开该文件夹； 点击文件：调用默认程序打开文件； 同时按住 option 键，可以以矩形选中，类似于 vim 中的 ctrl v 操作。 高亮当前鼠标的位置一个标签页中开的窗口太多，有时候会找不到当前的鼠标，Command+/ 找到它。 参考链接iTerm2 &amp; Oh My Zsh：完爆mac终端Iterm2+solarized+zsh+oh my zshitem2启动慢的解决让 iTrem 2 + zsh 启动不再等待一些命令行效率工具]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>iterm</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 优化和备份]]></title>
    <url>%2Fother%2FHexo%20%E4%BC%98%E5%8C%96%E5%92%8C%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[Hexo 优化和备份gulp精简博客代码Next 主题在 Hexo 引擎解析 md 时生成的代码会包含大量的无用空白。这些空白会增加文档的大小,使得网站在响应上不够迅速,影响体验。使用的 gulp 是一个前端项目构建工具,用自动化构建工具增强你的工作流程gulp中文官网。 gulp简介首先是 gulp 的一些简单介绍：gulp是基于nodejs流的自动化构建工具，可以快速构建项目并减少频繁的I/0操作。你可以利用gulp插件完成各种自动化任务：测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。 安装安装有两种方式：1.全局安装gulp 1npm install -g -d gulp 运行 gulp -v ,如果正常打印版本号则安装成功。 2.安装到项目本地先CD到你的项目根目录 1npm install gulp --save-dev --save-dev 保存 gulp 到项目依赖文件 package.json 的devDependencies 里面。 插件gulp的插件列表可以参考gulp的插件官网。 以下是比较常用的插件 gulp-minify-css 压缩css gulp-htmlmin 压缩html gulp-uglify 压缩js gulp-rename 重命名文件,通常压缩后的带.min后缀 gulp-jshint jshint,js静态检查 gulp-concat 合并多个文件 gulp-imagemin 压缩图片 gulp-clean 清理文件或目录 gulp-load-plugins 自动加载插件 run-sequence 控制任务执行顺序 npm install [plugins-name] –save上述命令安装插件的同时也会把插件作为项目依赖写入package.json文件. gulp APIgulp.src（gobs[, options]) 输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。 123gulp.src('src/js/*.js') //模糊匹配src/js文件夹下所有js文件 .pipe( concat('app.js')) //合并后的文件名 .pipe(gulp.dest('pub/dist/js'));//合并后文件路径 gulp.src通配符匹配：.js匹配当前目录下的所有js文件,不指名扩展名则匹配所有类型 /.js匹配所有第一层子文件夹的js文件,第二层请用//.js**/.js匹配所有文件夹层次下的js文件, 包括当前目录?匹配文件路径中的一个字符(不会匹配路径分隔符)[…]匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个.!匹配任何与括号中给定的任一模式都不匹配的 下面以一系列例子来加深理解： 1234567891011*能匹配 a.js,x.y,abc,abc/,但不能匹配a/b.js*.*能匹配 a.js,style.css,a.b,x.y*/*/*.js能匹配 a/b/c.js,x/y/z.js,不能匹配a/b.js,a/b/c/d.js**能匹配 abc,a/b.js,a/b/c.js,x/y/z,x/y/z/a.b,能用来匹配所有的目录和文件**/*.js 能匹配 foo.js,a/foo.js,a/b/foo.js,a/b/c/foo.jsa/**/z能匹配 a/z,a/b/z,a/b/c/z,a/d/g/h/j/k/za/**b/z 能匹配 a/b/z,a/sb/z,但不能匹配a/x/sb/z,因为只有单**单独出现才能匹配多级目录?.js 能匹配 a.js,b.js,c.jsa??能匹配 a.b,abc,但不能匹配ab/,因为它不会匹配路径分隔符[xyz].js只能匹配 x.js,y.js,z.js,不会匹配xy.js,xyz.js等,整个中括号只代表一个字符[^xyz].js能匹配 a.js,b.js,c.js等,不能匹配x.js,y.js,z.js gulp.dest(path[, options]) 能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。 12345gulp.src(&apos;./client/templates/*.jade&apos;) .pipe(jade()) .pipe(gulp.dest(&apos;./build/templates&apos;)) .pipe(minify()) .pipe(gulp.dest(&apos;./build/minified_templates&apos;)); 文件被写入的路径是以所给的相对路径根据所给的目标目录计算而来。类似的，相对路径也可以根据所给的 base 来计算。 gulp.task(name[, deps], fn)定义一个使用 Orchestrator 实现的任务（task）。 123gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() &#123; // 做一些事&#125;); gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb])监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。 需要在文件变动后执行的一个或者多个通过 gulp.task() 创建的 task 的名字， 1234var watcher = gulp.watch('js/**/*.js', ['uglify','reload']);watcher.on('change', function(event) &#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');&#125;); 每次变动需要执行的 callback。 123gulp.watch(&apos;js/**/*.js&apos;, function(event) &#123; console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);&#125;); gulp优化在hexo顶层目录运行以下代码来安装 gulp 和插件 1npm install --save-dev gulp gulp-clean gulp-load-plugins gulp-minify-css gulp-htmlmin gulp-imagemin gulp-uglify run-sequence 在hexo顶层目录下创建 gulpfile.js 文件 内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596var gulp = require('gulp'), plugins = require('gulp-load-plugins')(); //自动插件引用var Hexo = require('hexo');var runSequence = require('run-sequence');// 清除public文件夹gulp.task("clean",function() &#123; return gulp.src("public/*") .pipe(plugins.clean()); &#125;);// 压缩css文件gulp.task("minify-css",function() &#123; return gulp.src(["public/**/*.css","!public/**/*.min.css"]) .pipe(plugins.minifyCss(&#123;compatibility: "ie8"&#125;)) .pipe(gulp.dest("./public")); &#125;);// 压缩js文件gulp.task("minify-js",function() &#123; return gulp.src(["public/**/*.js","!public/**/*.min.js"]) .pipe(plugins.uglify()) .pipe(gulp.dest("./public"));&#125;);// 压缩html文件gulp.task("minify-html",function() &#123; return gulp.src("public/**/*.html") .pipe(plugins.htmlmin(&#123; removeComments: true, collapseWhitespace: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest("./public"));&#125;);// 压缩 public/images 和 /public/uploads目录内图片gulp.task('minify-images', function() &#123; gulp.src(['./public/images/**/*.&#123;png,jpg,gif,ico&#125;','./public/uploads/**/*.&#123;png,jpg,gif,ico&#125;']) .pipe(plugins.imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: true, //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest('./public/uploads'));&#125;);// 利用Hexo API 来生成博客内容， 效果和在命令行运行： hexo g 一样var hexo = new Hexo(process.cwd(), &#123;&#125;);gulp.task('generate', function(cb) &#123; hexo.init().then(function() &#123; return hexo.call('generate', &#123; watch: false &#125;); &#125;).then(function() &#123; return hexo.exit(); &#125;).then(function() &#123; return cb() &#125;).catch(function(err) &#123; hexo.exit(err); return cb(err); &#125;)&#125;);// 利用Hexo API 来发布博客， 效果和在命令行运行： hexo d 一样gulp.task('deploy', function(cb) &#123; hexo.init().then(function() &#123; return hexo.call('deploy', &#123; watch: false &#125;); &#125;).then(function() &#123; return hexo.exit(); &#125;).then(function() &#123; return cb() &#125;).catch(function(err) &#123; hexo.exit(err); return cb(err); &#125;)&#125;);// 用run-sequence并发执行，同时处理html，css，js，imggulp.task('minify', function(cb) &#123; runSequence(['minify-html', 'minify-css', 'minify-js', 'minify-images'], cb);&#125;);// 执行顺序： 清除public目录 -&gt; 产生原始博客内容 -&gt; 执行压缩混淆gulp.task('build', function(cb) &#123; runSequence('clean', 'generate', 'minify', 'deploy', cb)&#125;);gulp.task('default', ['build']); 到这里对 gulp 的配置就完成了，只需要每次在执行 gulp 就可以生成静态文件并实现发布。 1gulp 但是每次都要把 public 中的文件都删除，重新生成静态文件并发布会比较慢，先记下这个问题，以后解决。 hexo备份备份新建仓库 blog 来存储博客原始文件，先看一下哪些文件是必须备份的：像站点配置 _config.yml，主题 theme，博客文件 source，文章的模板 caffolds，安装包 package.json， 提交忽略配置 .gitignore 这些文件是需要备份的。其它可以不需要，则 .gitignore 如下配置(已经配置好了): 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 直接在博客顶层目录使用以下命令： 12345git initgit add -Agit commit -m "first commit"git remote add origin git@github.com:yourName/blog.gitgit push -u origin master 这样就把博客备份到仓库中了。在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行备份和发布： 1234git add .git commit -m "..."git push #备份hexo g -d #发布 还原使用 clone 拷贝仓库 12git init git clone git@github.com:yourName/blog.git 在本地新拷贝的文件夹下通过以下命令： 123cd blognpm install #模块安装hexo s -g #预览 注：这里没用 hexo init 初始化 此时用了 hexo init，则站点的配置文件 _config.yml 里面内容会被清空使用默认值，所以不要用 hexo init。 预览http://localhost:4000/没有问题，就可以使用了。 参考链接gulp中文官网优化Hexo博客 - 压缩 HTML、CSS、JS、IMG 等hexo api知乎 CrazyMilk 和 skycrown 的回答]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 个人博客]]></title>
    <url>%2Fother%2FHexo%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 个人博客简介Hexo是基于Node.js的静态博客框架，简单、轻量，其生成的静态网页可以托管在Github。使用 GitHubPages + Hexo，一种简单高效的实现方式来搭建个人的博客。 环境准备安装node.js去nodejs官网下载对应系统的安装包，按提示安装。 或 Homebrew 安装方式，此安装方式无需重启 1brew install node 安装Git一般都安装了，查看是否安装 git 命令，没有安装会提示安装。希望下载最新的可以去git官网下载 安装hexo使用npm安装 1sudo npm install -g hexo-cli 安装完成创建并初始化放博客的文件夹,然后定位到存储博客的目录并安装。 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 解决 Error: Cannot find module &#39;./build/Release/DTraceProviderBindings&#39; 错误删除node中的 lib/node_modules/hexo-cli 和 bin/hexo 重新安装 目前我安装所用的本地环境如下：(可以通过hexo -v查看） 123456789101112hexo: 3.3.7hexo-cli: 1.0.3os: Darwin 16.5.0 darwin x64http_parser: 2.7.0node: 6.11.0v8: 5.1.281.102uv: 1.11.0zlib: 1.2.11ares: 1.10.1-DEVicu: 58.2modules: 48openssl: 1.0.2k hexo 命令 hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹 hexo server (hexo s) 启动本地web服务，用于博客的预览 hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台） hexo new (hexo n) “postName” 新建文章 hexo new (hexo n) page “pageName” 新建页面 hexo clean 清除缓存文件和已生成的静态文件 hexo d -g #生成部署 (-g部署之前预先生成静态文件)hexo s -g #生成预览 选项 hexo –safe 安全模式，在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 hexo –debug 调试模式，在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次。 hexo –silent 简洁模式，隐藏终端信息 主题设置hexo 提供很多主题 这里选了一个极简的主题NexT，也是Hexo主题中最受欢迎的一个。 下载主题12cd your-hexo-file #Hexo 站点目录git clone https://github.com/iissnan/hexo-theme-next themes/next 失败的话直接到NexT发布页面下载并解压所下载的压缩包至站点的 themes 目录,需要将文件名改为next。 启用主题打开站点配置文件 _config.yml ,找到 theme 字段，并将其值更改为next 在切换主题之后、验证之前， 我们最好清除 Hexo 的缓存 1hexo clean 启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 1hexo s --debug 在服务启动的过程，注意观察命令行输出是否有任何异常信息,这些信息将帮助他人更好的定位错误。使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 主题设定基础配置123456789101112title: #你博客的标题subtitle: #你博客的副标题description: #你博客的描述author: #你的名字language: zh-Hans #语言 中文theme: next #安装的主题名称deploy: #发布 type: git #使用Git 发布 repo: https://github.com/username/username.github.io.git #你的Github仓库 url: http://yoursite.com #你的站点地址permalink: :title/ #url结构 SchemeScheme 是 NexT 为提供多种不同的外观而添加的，目前 NexT 支持三种样式他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 更改主题配置文件 scheme 关键字 菜单第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标(Font Awesome)。 菜单名称在 {language}.yml 文件中设置。菜单项的图标，对应的字段是 menu_icon，而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 添加菜单需要创建页面，如标签界面 1hexo new page tags 创建完成后，在对应的目录下找到 index.md 文件，进行如下的修改： 123456---title: tags # 标签名字（可为空）date: 2017-06-29 16:28:46type: &quot;tags&quot; # 将页面的类型设置为 tags,主题将自动为这个页面显示为标签云comments: false # 如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，设置为 false--- type 有分类 categories 标签 tags 侧栏sidebar 字段来控制侧栏的行为其一是侧栏的位置 sidebar.position left - 靠左放置 right - 靠右放置 其二是侧栏显示的时机 sidebar.display post - 默认行为，在文章页面（拥有目录列表）时显示 always - 在所有页面中都显示 hide - 在所有页面中都隐藏（可以手动展开） remove - 完全移除 头像avatar 设置成头像的链接地址。其中，头像的链接地址可以是完整的互联网或站点内的地址（将头像放置主题目录下的 source/images/ 配置为avatar: /images/avatar.png） 否显示阅读全文将 auto_excerpt 的 enable 设置为 ture 则显示阅读全文 12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: ture # 设置是否显示阅读全文 length: 150 或在文章中使用 手动进行截断，Hexo 提供的方式（推荐） 代码高亮NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties。 可更改 highlight_theme 字段 社交链接链接放置在 social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址。设定链接的图标，对应的字段是 social_icons，图标名称 是 Font Awesome 图标的名字（不必带 fa- 前缀） 动画效果use_motion，根据您的需求设置值为 true 或者 false，NexT 默认开启动画效果 12use_motion: true # 开启动画效果use_motion: false # 关闭动画效果 背景动画 canvas_nest 12canvas_nest: true //开启动画canvas_nest: false //关闭动画 改变 canvas 动画的配置 打开 layout/_scripts/vendors.swig 文件，根据canvas-nest.js文档进行如下更改： 12345678&#123;% for name, internal in js_vendors %&#125; &#123;% set internal_script = url_for(theme.vendors._internal) + '/' + internal %&#125; &#123;% if name === 'canvas_nest' %&#125; &lt;script type="text/javascript" color="135,218,255" opacity="0.6" count="66" src="&#123;&#123; theme.vendors[name] | default(internal_script) &#125;&#125;"&gt;&lt;/script&gt; &#123;% else %&#125; &lt;script type="text/javascript" src="&#123;&#123; theme.vendors[name] | default(internal_script) &#125;&#125;"&gt;&lt;/script&gt; &#123;% endif %&#125;&#123;% endfor %&#125; 背景图片要添加背景图片，首先将图片 background.jpg 放到 /source/uploads/ 目录下，然后，在文件 /css/_custom/custom.styl文件中添加下面一行内容： 1body &#123; background:url(/uploads/background.jpg);&#125; 同样可以添加其它背景，如侧栏背景 sidebar ，头部 header 等。 腾讯公益404页面腾讯公益404页面，寻找丢失儿童，让大家一起关注此项公益事业！ 新建 404.html 页面，放到主题的 source 目录下，内容如下： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Github Pages设置GitHub Pages 本用于介绍托管在GitHub的项目，不过由于他的空间免费稳定，常用来做搭建博客。 每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是 username/username.github.io ，这是特殊的命名约定。你可以通过 http://username.github.io 来访问你的个人主页。 仓库创建好就可以部署了，要部署到github，需要在站点配置文件_config.xml中作如下修改： 12345deploy: type: git repo: &lt;repository url&gt; #库（Repository）地址 branch: [branch] #分支名称默认 master message: [message] #自定义提交信息 (默认为 Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;) 安装一个扩展：hexo-deployer-git 1npm install hexo-deployer-git --save 然后在命令行中执行 1hexo d 如果出现下面错误，则是因为没有设置好public key所致。 1234Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 解决：在本机生成public key： 1ssh-keygen -t rsa -C "youremail@example.com" 然后在用户主目录里找到.ssh目录，里面有 id_rsa 和 id_rsa.pub 两个文件。然后登陆github，在SSH设置页面添加上 id_rsa.pub 文件中的内容即可。 插件SitemapSitemap 的目的是要避免搜索引擎的爬虫没有完整的收录整个网页的内容，所以提交 Sitemap 是能够补足搜索引擎的不足，进而加速网页的收录速度，达到搜寻引擎友好的目的。 安装 1npm install hexo-generator-sitemap --save 在 Hexo 根目录下的 _config.yml 里配置一下 123sitemap: path: sitemap.xml template: ./sitemap_template.xml 对于国内用户还需要安装插件 hexo-generator-baidu-sitemap 1npm install hexo-generator-baidu-sitemap --save 添加配置 12baidusitemap: path: baidusitemap.xml 完成之后就可以将 sitemap 文件提交谷歌和百度，提交过程可以查看sunshine小小倩的文章。 RSS安装hexo-generator-feed 1npm install hexo-generator-feed --save 然后在 Hexo 根目录下的 _config.yml 里配置一下 1234feed: type: atom #type 表示类型, 是 atom 还是 rss2. path: atom.xml #path 表示 Feed 路径 limit: 20 #limit 最多多少篇最近文章 添加RSS链接,打开 themes/next/_config.yml 文件，rss: 部分修改为 rss: /atom.xml。 Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1npm install hexo-generator-searchdb --save 编辑站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 博客管理文章可以直接把写好的文章插入到目录 /_posts 下面，后缀为.MD就行，在文章头部固定格式： 1234title: title #文章的标题，这个才是显示的文章标题，其实文件名不影响date: 2015-09-01 20:33:26 #用命令会自动生成，也可以自己写，所以文章时间可以改categories: categories #文章的分类，这个可以自己定义tags: [tag] #tag，为文章添加标签，方便搜索 或 1hexo new &quot;new article&quot; 文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。 分类和标签格式 12345categories:- 日记tags:- Hexo- node.js 草稿相当于很多博客都有的“私密文章”功能。 1hexo new draft &quot;new draft&quot; 会在 source/_drafts 目录下生成一个 new-draft.md 文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到 _drafts目录之中。 如果你希望强行预览草稿，更改站点配置文件： 1render_drafts: true 或者，如下方式启动server： 1hexo server --drafts 下面这条命令可以把草稿变成文章，或者页面： 1hexo publish [layout] &lt;filename&gt; 参考链接Hexo官网手把手教你使用Hexo + Github Pages搭建个人独立博客Hexo搭建Github-Pages博客填坑教程NexT主题Hexo 入门指南GitHubPages + Hexo — 博客搭建hexo高阶教程]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2Fleft%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[第一篇博客一直想写博客的，但一直总是在忙项目，有时间也是玩会儿游戏，最近把游戏卸了，总算有时间了。以后会把写博客养成一个习惯，努力一个星期最少一篇，实在没时间就把之前写到印象笔记的文章重新整理一下。明天把搭建博客的过程写一下。 现在写下来激励自己，加油。]]></content>
      <categories>
        <category>left</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>